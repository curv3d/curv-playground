<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  html, body { margin: 0; padding: 0; border: none; }
  
  .editor {
    border-radius: 6px;
    box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12), 0 3px 1px -2px rgba(0, 0, 0, 0.2);
    font-family: 'Source Code Pro', monospace;
    font-size: 14px;
    font-weight: 400;
    height: 340px;
    letter-spacing: normal;
    line-height: 20px;
    padding: 10px;
    tab-size: 4;
  }

  .actions {
    position: absolute;
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    width: 100%;
    color: white;
    font-family: 'Source Code Pro', monospace;
  }

  .actions-buttons {
    display: flex;
    flex-direction: row;
  }

  .actions-buttons > button, .actions-buttons > input::file-selector-button {
    width: 16mm;
    height: 13mm;
  }

  .actions-buttons > input::file-selector-button {
    content: "Open";
  }
  
  .errors_outer {
    position: relative;
    top: 13mm;
  }
  
  .errors {
    position: absolute;
    z-index: 10;
    background-color: rgba(255, 221, 255, 0.9);
    font-family: 'Source Code Pro', monospace;
    font-size: 0.65em;
  }

  .hide {
    display: none;
  }
</style>

<div class="editor"></div>

<div class="actions">
  <div class="actions-buttons">
    <button onclick="save()">Save</button>
    <input type="file" onchange="openFile(event)">
  </div>

  <div class="actions-buttons">
    <button onclick="render3D()">3d</button>
    <button onclick="render2D()">2d</button>
  </div>
</div>

<div class="errors_outer hide">
  <div class="errors"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.121.0/build/three.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.121.0/examples/js/controls/OrbitControls.js"></script>
<script type="module">
  import { CodeJar } from 'https://medv.io/codejar/codejar.js';
  import { withLineNumbers } from 'https://medv.io/codejar/linenumbers.js';
  
  import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.121.0/examples/jsm/loaders/GLTFLoader.js";
	const loader = new GLTFLoader();
  const scene = new THREE.Scene();
  let camera;
  
  var editor = document.querySelector('.editor');
  var errorsOuterEl = document.querySelector('.errors_outer');
  var errorsEl = document.querySelector('.errors');
  
  let jar = CodeJar(
    document.querySelector('.editor'),
    withLineNumbers(function() {}),
    {
      tab: '  '
    }
  );

  const anchor = document.createElement('a');
  window.save = async function() {
    const message = editor.innerText;
    
    const encoder = new TextEncoder();
    const data = encoder.encode(message);
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    
    const blob = new Blob([message], { type: 'text/plain' });
    anchor.download = hashHex + ".curv";
    anchor.href = (window.webkitURL || window.URL).createObjectURL(blob);
    anchor.dataset.downloadurl = ['text/plain', anchor.download, anchor.href].join(':');
    anchor.click();
  };
  
  window.openFile = function(e) {
    var file = e.target.files[0];
    if (!file) { return; }
    var reader = new FileReader();
    reader.addEventListener("load", function() {
      jar.updateCode(reader.result);
    });
    reader.readAsText(file);
  }
  window.render3D = function() {
    const text = editor.innerText;
    errorsOuterEl.classList.add('hide');
    fetch('/render-3d', {
      method: 'POST',
      body: text
    })
    .then((r) => r.ok ? r : Promise.reject(r))
    .then((r) => r.arrayBuffer())
    .then((ab) => {
      loader.parse(ab, undefined, function ( gltf ) {
        for( var i = scene.children.length - 1; i >= 0; i--) {
          obj = scene.children[i];
          scene.remove(obj);
        }
      	gltf.scene.children[0].material.wireframe = true;
      	scene.add( gltf.scene );
      	console.log(gltf);
        fitCameraToObject( camera, gltf.scene.children[0], 26, controls );
      }, function ( error ) {
       errorsEl.innerText = error;
       errorsOuterEl.classList.remove('hide');
      });
    })
    .catch((r) => {
      r
      .text()
      .then((t) => {
         errorsEl.innerText = t;
         errorsOuterEl.classList.remove('hide');
      });
    });
  }
  window.render2D = function() { alert("Not implemented"); }
    
  const renderer = new THREE.WebGLRenderer({ alpha: true, physicallyCorrectLights: true, gammaOutput: true });
  
  const renderHeight = window.innerHeight - editor.offsetHeight;
  const renderWidth = window.innerWidth;

  errorsEl.style.width = window.innerWidth + 'px';
  errorsEl.style.height = `calc(${renderHeight}px - 13mm)`;
  
  camera = new THREE.PerspectiveCamera(75, renderWidth / renderHeight, 0.1, 1000);
  renderer.setSize(renderWidth, renderHeight);
  document.body.appendChild(renderer.domElement);

  const light4 = new THREE.AmbientLight('#00ffff', 200);
  camera.add( light4 );
  const light = new THREE.DirectionalLight('#00ffff', 400);
  light.position.set(0.5, 0, 0.866); // ~60ยบ
  camera.add( light );

  var controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.target.set(0, 100, 0);
  controls.update();

  window.addEventListener('resize', onWindowResize, false);
  
  function onWindowResize() {
    const renderHeight = window.innerHeight - editor.offsetHeight;
    const renderWidth = window.innerWidth;
    
    camera.aspect = renderWidth / renderHeight;
    camera.updateProjectionMatrix();
    
    renderer.setSize( renderWidth, renderHeight);
  }
  
  function animate() {
    requestAnimationFrame( animate );
    renderer.render( scene, camera );
  }
  animate();

  var fitCameraToObject = function ( camera, object, offset, controls ) {

    offset = offset || 1.25;

    const boundingBox = new THREE.Box3();

    // get bounding box of object - this will be used to setup controls and camera
    boundingBox.setFromObject( object );

    const center = boundingBox.getCenter();

    const size = boundingBox.getSize();

    // get the max side of the bounding box (fits to width OR height as needed )
    const maxDim = Math.max( size.x, size.y, size.z );
    const fov = camera.fov * ( Math.PI / 180 );
    let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) );

    cameraZ *= offset; // zoom out a little so that objects don't fill the screen

    camera.position.z = cameraZ;

    const minZ = boundingBox.min.z;
    const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ;

    camera.far = cameraToFarEdge * 3;
    camera.updateProjectionMatrix();

    if ( controls ) {

      // set camera to rotate around center of loaded object
      controls.target = center;

      // prevent camera from zooming out far enough to create far plane cutoff
      controls.maxDistance = cameraToFarEdge * 2;

      controls.saveState();

    } else {
        camera.lookAt( center )
    }
   };
</script>
